"""Integration tests for write_query_azure using the Sakila database.

These tests compare the results of LLM-generated SQL queries with expected queries
to validate correctness. Vector DB retrieval and error handling are also tested.

Run the tests using:  pytest Test_Files/test_write_query_azure.py -v -s
"""

#Intergation tests for write_query_azure function. Made only for the sakila database.
# These tests will compare the results of the generated query with expected queries that we know produce correct results.

import os
import sys
import sqlite3
import pytest
from dotenv import load_dotenv
from langchain_community.utilities import SQLDatabase

try:
    import Code
except ImportError:
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from Code.azure_functions import write_query_azure, query_collection_azure, client
import Code.config as cfg

# Add the project root to the Python path instead of just the Code directory
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Load environment variables
load_dotenv()

# Test questions and their corresponding expected queries (that we know produce correct results)
test_cases = [
    {
        "question": "How many actors are there in the database?",
        "expected_query": "SELECT COUNT(*) FROM actor;",
        "description": "Count total actors"
    },
    {
        "question": "What is the name of the actor with ID 1?",
        "expected_query": "SELECT first_name, last_name FROM actor WHERE actor_id = 1;",
        "description": "Get specific actor by ID"
    },
    {
        "question": "List the first 3 movies released in 2006.",
        "expected_query": "SELECT title FROM film WHERE release_year = 2006 ORDER BY title LIMIT 3;",
        "description": "Get films by year with limit"
    },
    {
        "question": "What is the average rental rate for movies?",
        "expected_query": "SELECT AVG(rental_rate) FROM film;",
        "description": "Calculate average rental rate"
    },
    {
        "question": "How many customers are there in the database?",
        "expected_query": "SELECT COUNT(*) FROM customer;", 
        "description": "Count total customers"
    },
    {
        "question": "What is the total revenue generated by all rentals?",
        "expected_query": "SELECT SUM(amount) FROM payment;",
        "description": "Sum all payments"
    },
    {
        "question": "Who are the top 2 actors with the most movies?",
        "expected_query": "SELECT a.first_name, a.last_name, COUNT(fa.film_id) AS film_count FROM actor a JOIN film_actor fa ON a.actor_id = fa.actor_id GROUP BY a.actor_id, a.first_name, a.last_name ORDER BY film_count DESC LIMIT 2;",
        "description": "Top actors by film count"
    },
    {
        "question": "Which customer rented the most movies?",
        "expected_query": "SELECT c.first_name, c.last_name, COUNT(r.rental_id) AS rental_count FROM customer c JOIN rental r ON c.customer_id = r.customer_id GROUP BY c.customer_id, c.first_name, c.last_name ORDER BY rental_count DESC LIMIT 1;",
        "description": "Customer with most rentals"
    },
    {
        "question": "List all movies that have never been rented.",
        "expected_query": "SELECT f.title FROM film f LEFT JOIN inventory i ON f.film_id = i.film_id LEFT JOIN rental r ON i.inventory_id = r.inventory_id WHERE r.rental_id IS NULL;",
        "description": "Movies never rented"
    },
    {
        "question": "Which staff member processed the most payments?",
        "expected_query": "SELECT s.first_name, s.last_name, COUNT(p.payment_id) AS payment_count FROM staff s JOIN payment p ON s.staff_id = p.staff_id GROUP BY s.staff_id, s.first_name, s.last_name ORDER BY payment_count DESC LIMIT 1;",
        "description": "Staff with most payments"
    },
    {
        "question": "What is the total amount paid by customer with ID 5?",
        "expected_query": "SELECT SUM(amount) FROM payment WHERE customer_id = 5;",
        "description": "Total payments by customer"
    },
    {
        "question": "List the top 3 cities with the most customers.",
        "expected_query": "SELECT ci.city, COUNT(c.customer_id) AS customer_count FROM customer c JOIN address a ON c.address_id = a.address_id JOIN city ci ON a.city_id = ci.city_id GROUP BY ci.city ORDER BY customer_count DESC LIMIT 3;",
        "description": "Cities with most customers"
    },
    {
        "question": "Which movie category has the highest average rental rate?",
        "expected_query": "SELECT c.name, AVG(f.rental_rate) AS avg_rate FROM category c JOIN film_category fc ON c.category_id = fc.category_id JOIN film f ON fc.film_id = f.film_id GROUP BY c.category_id, c.name ORDER BY avg_rate DESC LIMIT 1;",
        "description": "Category with highest avg rental rate"
    },
    {
        "question": "Find the longest movie in the database.",
        "expected_query": "SELECT title, length FROM film ORDER BY length DESC LIMIT 1;",
        "description": "Longest movie"
    },
    {
        "question": "Which movies were rented by customer 'Mary Smith'?",
        "expected_query": "SELECT f.title FROM customer c JOIN rental r ON c.customer_id = r.customer_id JOIN inventory i ON r.inventory_id = i.inventory_id JOIN film f ON i.film_id = f.film_id WHERE c.first_name = 'Mary' AND c.last_name = 'Smith';",
        "description": "Movies rented by specific customer"
    },
    {
        "question": "List all actors who appeared in the movie 'ACADEMY DINOSAUR'.",
        "expected_query": "SELECT a.first_name, a.last_name FROM actor a JOIN film_actor fa ON a.actor_id = fa.actor_id JOIN film f ON fa.film_id = f.film_id WHERE f.title = 'ACADEMY DINOSAUR';",
        "description": "Actors in a specific movie"
    },
    {
        "question": "Which movies have been rented more than 10 times?",
        "expected_query": "SELECT f.title, COUNT(r.rental_id) AS rental_count FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY f.film_id, f.title HAVING rental_count > 10;",
        "description": "Movies rented more than 10 times"
    },
    {
        "question": "What is the average payment amount per rental?",
        "expected_query": "SELECT AVG(amount) FROM payment;",
        "description": "Average payment per rental"
    },
    {
        "question": "List the top 5 most rented movie categories.",
        "expected_query": "SELECT c.name, COUNT(r.rental_id) AS rental_count FROM category c JOIN film_category fc ON c.category_id = fc.category_id JOIN film f ON fc.film_id = f.film_id JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id GROUP BY c.category_id, c.name ORDER BY rental_count DESC LIMIT 5;",
        "description": "Top rented categories"
    }]

@pytest.fixture
def db_connection():
    """Create and return a database connection."""
    connection = sqlite3.connect(cfg.DB_PATH) #Ensure the DB_PATH is set for the sakilla.db
    yield connection
    connection.close()


class TestWriteQueryAzure:
    """Test cases for write_query_azure function by comparing query results."""
    
    def test_write_query_azure_results_comparison(self, db_connection):
        """ Args:
        db_connection: Database connection fixture.
        This function will run a series of tests to validate the query generation and execution process.
        It will compare the results of the generated query against expected queries that are known to produce correct"""
        
        cursor = db_connection.cursor()
        passed_tests = 0
        total_tests = len(test_cases)
        
        print(f"\nğŸ§ª Running {total_tests} query generation tests...\n")
        
        for i, test_case in enumerate(test_cases):
            question = test_case["question"]
            expected_query = test_case["expected_query"]
            description = test_case["description"]
            
            print(f"ğŸ” Test {i+1}/{total_tests}: {description}")
            print(f"   Question: {question}")
            
            # Step 1: Execute expected query to get correct results
            try:
                cursor.execute(expected_query)
                expected_results = cursor.fetchall()
                print(f"   âœ“ Expected query executed: {len(expected_results)} results")
                print(f"   ğŸ“Š Expected query: {expected_query}")
            except Exception as e:
                print(f"   âŒ Error executing expected query: {e}")
                continue
            
            # Step 2: Get relevant tables from vector database
            try:
                tables = query_collection_azure(prompt=question)
                if not tables or not tables.get("documents"):
                    print("   âš ï¸ No relevant tables found for question")
                    continue
                    
                context_tables = "\n".join(tables["documents"])
                print(f"   âœ“ Retrieved {len(tables['documents'])} relevant tables")
                
            except Exception as e:
                print(f"   âŒ Error querying vector collection: {e}")
                continue
            
            # Step 3: Generate query using Azure OpenAI
            try:
                result = write_query_azure(
                    question=question,
                    client=client,
                    context_tables=context_tables
                )
                
                generated_query = result.get("query")
                print(f"   ğŸ¤– Generated query: {generated_query}")
                
                if generated_query == "Error generating query":
                    print("   âŒ Query generation failed")
                    continue
                    
                if not generated_query.strip().lower().startswith("select"):
                    print("   âš ï¸ Generated query is not a SELECT statement")
                    continue
                    
            except Exception as e:
                print(f"   âŒ Error calling write_query_azure: {e}")
                continue
            
            # Step 4: Execute generated query and compare results
            try:
                cursor.execute(generated_query)
                generated_results = cursor.fetchall()
                print(f"   âœ“ Generated query executed: {len(generated_results)} results")
                
                # Compare the results
                if self._compare_query_results(expected_results, generated_results):
                    print("   âœ… TEST PASSED: Results match!")
                    passed_tests += 1
                else:
                    print("   âŒ TEST FAILED: Results don't match")
                    print(f"      Expected: {expected_results[:2]}{'...' if len(expected_results) > 2 else ''}")
                    print(f"      Generated: {generated_results[:2]}{'...' if len(generated_results) > 2 else ''}")
                    
            except Exception as e:
                print(f"   âŒ Error executing generated query: {e}")
                
            print()  # Add spacing between tests
        
        # Final summary
        print(f"ğŸ¯ Test Summary: {passed_tests}/{total_tests} tests passed ({passed_tests/total_tests*100:.1f}%)")
        
        # Assert that at least 70% of tests pass (adjust threshold as needed)
        assert passed_tests >= total_tests * 0.7, f"Only {passed_tests}/{total_tests} tests passed. Expected at least 70%."
    
    def _compare_query_results(self, expected, generated):
        """Compare two result sets, handling different data types and ordering."""
        if len(expected) != len(generated):
            return False
        
        # For single-value results (like COUNT, AVG, SUM)
        if len(expected) == 1 and len(expected[0]) == 1:
            # Handle floating point comparison for averages
            if isinstance(expected[0][0], (int, float)) and isinstance(generated[0][0], (int, float)):
                return abs(float(expected[0][0]) - float(generated[0][0])) < 0.01
            else:
                return expected[0][0] == generated[0][0]
        
        # For multi-row results, compare as sets (ignoring order)
        try:
            expected_set = set(expected)
            generated_set = set(generated)
            return expected_set == generated_set
        except TypeError:
            # If results contain unhashable types, compare as sorted lists
            try:
                return sorted(expected) == sorted(generated)
            except TypeError:
                # If sorting fails, compare element by element (preserving order)
                return expected == generated
    
    def test_write_query_azure_error_handling(self):
        """Test error handling when no context tables are provided."""
        
        result = write_query_azure(
            question="Test question with no context",
            client=client,
            context_tables=""
        )
        
        # Should return error or handle gracefully
        assert "query" in result, "Result should contain 'query' key"
        print(f"âœ… Error handling test: {result['query']}")
    
    def test_vector_database_integration(self):
        """Test that vector database returns relevant tables for questions."""
        
        test_questions = [
            "How many actors are there?",
            "What is the average rental rate?", 
            "How many customers do we have?"
        ]
        
        for question in test_questions:
            print(f"\nğŸ” Testing vector DB for: {question}")
            
            try:
                tables = query_collection_azure(prompt=question)
                
                if tables and tables.get("documents"):
                    print(f"   âœ“ Retrieved {len(tables['documents'])} tables")
                    # Check that we got actual table schemas
                    for doc in tables["documents"][:2]:  # Show first 2
                        print(f"   ğŸ“‹ Table info: {doc[:100]}...")
                else:
                    print("   âš ï¸ No tables retrieved")
                    
            except Exception as e:
                print(f"   âŒ Error querying vector database: {e}")


if __name__ == "__main__":
    # Run tests with verbose output
    pytest.main([__file__, "-v", "-s"])
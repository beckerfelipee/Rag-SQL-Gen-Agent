"""Integration tests for write_query_azure using the Sakila database.

These tests compare the results of LLM-generated SQL queries with expected queries
to validate correctness. Vector DB retrieval and error handling are also tested.

Run the tests using:  pytest Test_Files/test_write_query_azure.py -v -s

Description of the tests:
- `test_write_query_azure_results_comparison`: Tests basic query generation and result comparison.
- `test_write_query_azure_error_handling`: Tests error handling when no context tables are provided.
- `test_vector_database_integration`: Tests that the vector database returns relevant tables for questions.
- `test_write_query_azure_complex_questions`: Tests complex, multi-table queries and result comparison.
""" 

import os
import sys
import sqlite3
import logging
import datetime
import pytest
from dotenv import load_dotenv

# Ensure logs directory exists inside Test_Files
log_dir = os.path.join(os.path.dirname(__file__), "logs")
os.makedirs(log_dir, exist_ok=True)
date = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

# Configure logging to file and console
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(
            os.path.join(log_dir, f"test_write_query_azure_{date}.log"),
            mode='w', encoding='utf-8'
        ),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

try:
    import Code
except ImportError:
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from Code.azure_functions import write_query_azure, query_collection_azure, client
import Code.config as cfg

# Load environment variables
load_dotenv()

# Test questions and their corresponding expected queries (that we know produce correct results)
test_cases = [
    {
        "question": "How many actors are there in the database?",
        "expected_query": "SELECT COUNT(*) FROM actor;",
        "description": "Count total actors"
    },
    {
        "question": "What is the name of the actor with ID 1?",
        "expected_query": (
            "SELECT first_name, last_name FROM actor WHERE actor_id = 1;"
        ),
        "description": "Get specific actor by ID"
    },
    {
        "question": "List the first 3 movies released in 2006.",
        "expected_query": (
            "SELECT title FROM film WHERE release_year = 2006 "
            "ORDER BY title LIMIT 3;"
        ),
        "description": "Get films by year with limit"
    },
    {
        "question": "What is the average rental rate for movies?",
        "expected_query": "SELECT AVG(rental_rate) FROM film;",
        "description": "Calculate average rental rate"
    },
    {
        "question": "How many customers are there in the database?",
        "expected_query": "SELECT COUNT(*) FROM customer;",
        "description": "Count total customers"
    },
    {
        "question": "What is the total revenue generated by all rentals?",
        "expected_query": "SELECT SUM(amount) FROM payment;",
        "description": "Sum all payments"
    },
    {
        "question": "Who are the top 2 actors with the most movies?",
        "expected_query": (
            "SELECT a.first_name, a.last_name, COUNT(fa.film_id) AS film_count "
            "FROM actor a JOIN film_actor fa ON a.actor_id = fa.actor_id "
            "GROUP BY a.actor_id, a.first_name, a.last_name "
            "ORDER BY film_count DESC LIMIT 2;"
        ),
        "description": "Top actors by film count"
    },
    {
        "question": "Which customer rented the most movies?",
        "expected_query": (
            "SELECT c.first_name, c.last_name, COUNT(r.rental_id) AS rental_count "
            "FROM customer c JOIN rental r ON c.customer_id = r.customer_id "
            "GROUP BY c.customer_id, c.first_name, c.last_name "
            "ORDER BY rental_count DESC LIMIT 1;"
        ),
        "description": "Customer with most rentals"
    },
    {
        "question": "List all movies that have never been rented.",
        "expected_query": (
            "SELECT f.title FROM film f LEFT JOIN inventory i ON f.film_id = i.film_id "
            "LEFT JOIN rental r ON i.inventory_id = r.inventory_id "
            "WHERE r.rental_id IS NULL;"
        ),
        "description": "Movies never rented"
    },
    {
        "question": "Which staff member processed the most payments?",
        "expected_query": (
            "SELECT s.first_name, s.last_name, COUNT(p.payment_id) AS payment_count "
            "FROM staff s JOIN payment p ON s.staff_id = p.staff_id "
            "GROUP BY s.staff_id, s.first_name, s.last_name "
            "ORDER BY payment_count DESC LIMIT 1;"
        ),
        "description": "Staff with most payments"
    },
    {
        "question": "What is the total amount paid by customer with ID 5?",
        "expected_query": (
            "SELECT SUM(amount) FROM payment WHERE customer_id = 5;"
        ),
        "description": "Total payments by customer"
    },
    {
        "question": "List the top 3 cities with the most customers.",
        "expected_query": (
            "SELECT ci.city, COUNT(c.customer_id) AS customer_count "
            "FROM customer c JOIN address a ON c.address_id = a.address_id "
            "JOIN city ci ON a.city_id = ci.city_id "
            "GROUP BY ci.city ORDER BY customer_count DESC LIMIT 3;"
        ),
        "description": "Cities with most customers"
    },
    {
        "question": "Which movie category has the highest average rental rate?",
        "expected_query": (
            "SELECT c.name, AVG(f.rental_rate) AS avg_rate "
            "FROM category c JOIN film_category fc ON c.category_id = fc.category_id "
            "JOIN film f ON fc.film_id = f.film_id "
            "GROUP BY c.category_id, c.name ORDER BY avg_rate DESC LIMIT 1;"
        ),
        "description": "Category with highest avg rental rate"
    },
    {
        "question": "Find the longest movie in the database.",
        "expected_query": (
            "SELECT title, length FROM film ORDER BY length DESC LIMIT 1;"
        ),
        "description": "Longest movie"
    },
    {
        "question": "Which movies were rented by customer 'Mary Smith'?",
        "expected_query": (
            "SELECT f.title FROM customer c JOIN rental r ON c.customer_id = r.customer_id "
            "JOIN inventory i ON r.inventory_id = i.inventory_id "
            "JOIN film f ON i.film_id = f.film_id "
            "WHERE c.first_name = 'Mary' AND c.last_name = 'Smith';"
        ),
        "description": "Movies rented by specific customer"
    },
    {
        "question": "List all actors who appeared in the movie 'ACADEMY DINOSAUR'.",
        "expected_query": (
            "SELECT a.first_name, a.last_name FROM actor a "
            "JOIN film_actor fa ON a.actor_id = fa.actor_id "
            "JOIN film f ON fa.film_id = f.film_id "
            "WHERE f.title = 'ACADEMY DINOSAUR';"
        ),
        "description": "Actors in a specific movie"
    },
    {
        "question": "Which movies have been rented more than 10 times?",
        "expected_query": (
            "SELECT f.title, COUNT(r.rental_id) AS rental_count "
            "FROM film f JOIN inventory i ON f.film_id = i.film_id "
            "JOIN rental r ON i.inventory_id = r.inventory_id "
            "GROUP BY f.film_id, f.title HAVING rental_count > 10;"
        ),
        "description": "Movies rented more than 10 times"
    },
    {
        "question": "What is the average payment amount per rental?",
        "expected_query": "SELECT AVG(amount) FROM payment;",
        "description": "Average payment per rental"
    },
    {
        "question": "List the top 5 most rented movie categories.",
        "expected_query": (
            "SELECT c.name, COUNT(r.rental_id) AS rental_count "
            "FROM category c JOIN film_category fc ON c.category_id = fc.category_id "
            "JOIN film f ON fc.film_id = f.film_id "
            "JOIN inventory i ON f.film_id = i.film_id "
            "JOIN rental r ON i.inventory_id = r.inventory_id "
            "GROUP BY c.category_id, c.name ORDER BY rental_count DESC LIMIT 5;"
        ),
        "description": "Top rented categories"
    },
    {
        "question": "Which customer has spent the most money on rentals?",
        "expected_query": (
            "SELECT c.first_name, c.last_name, SUM(p.amount) AS total_spent "
            "FROM customer c "
            "JOIN payment p ON c.customer_id = p.customer_id "
            "GROUP BY c.customer_id, c.first_name, c.last_name "
            "ORDER BY total_spent DESC LIMIT 1;"
        ),
        "description": "Customer who spent the most on rentals"
    }
]

complex_cases = [
            {
                "question": (
                    "Which customers have rented every film in the 'Action' category at least once?"
                ),
                "expected_query": (
                    "SELECT c.first_name, c.last_name "
                    "FROM customer c "
                    "WHERE NOT EXISTS ("
                    "  SELECT f.film_id "
                    "  FROM film f "
                    "  JOIN film_category fc ON f.film_id = fc.film_id "
                    "  JOIN category cat ON fc.category_id = cat.category_id "
                    "  WHERE cat.name = 'Action' "
                    "  AND NOT EXISTS ("
                    "    SELECT 1 FROM rental r "
                    "    JOIN inventory i ON r.inventory_id = i.inventory_id "
                    "    WHERE r.customer_id = c.customer_id AND i.film_id = f.film_id"
                    "  )"
                    ");"
                ),
                "description": "Customers who rented every Action film"
            },
            {
                "question": (
                    "For each staff member, what is the total revenue they processed for rentals in 2006?"
                ),
                "expected_query": (
                    "SELECT s.first_name, s.last_name, SUM(p.amount) AS total_revenue "
                    "FROM staff s "
                    "JOIN payment p ON s.staff_id = p.staff_id "
                    "JOIN rental r ON p.rental_id = r.rental_id "
                    "WHERE strftime('%Y', r.rental_date) = '2006' "
                    "GROUP BY s.staff_id, s.first_name, s.last_name;"
                ),
                "description": "Staff revenue for 2006 rentals"
            },
            {
                "question": (
                    "Which films have never been rented by customers from the city of 'London'?"
                ),
                "expected_query": (
                    "SELECT f.title "
                    "FROM film f "
                    "WHERE NOT EXISTS ("
                    "  SELECT 1 FROM rental r "
                    "  JOIN inventory i ON r.inventory_id = i.inventory_id "
                    "  JOIN customer c ON r.customer_id = c.customer_id "
                    "  JOIN address a ON c.address_id = a.address_id "
                    "  JOIN city ci ON a.city_id = ci.city_id "
                    "  WHERE i.film_id = f.film_id AND ci.city = 'London'"
                    ");"
                ),
                "description": "Films never rented by London customers"
            },
            {
                "question": (
                    "List the top 3 categories by total revenue, and for each, the top-grossing film."
                ),
                "expected_query": (
                    "WITH cat_revenue AS ("
                    "  SELECT c.name AS category, SUM(p.amount) AS revenue "
                    "  FROM payment p "
                    "  JOIN rental r ON p.rental_id = r.rental_id "
                    "  JOIN inventory i ON r.inventory_id = i.inventory_id "
                    "  JOIN film f ON i.film_id = f.film_id "
                    "  JOIN film_category fc ON f.film_id = fc.film_id "
                    "  JOIN category c ON fc.category_id = c.category_id "
                    "  GROUP BY c.category_id, c.name"
                    "), "
                    "top_films AS ("
                    "  SELECT c.name AS category, f.title, SUM(p.amount) AS film_revenue "
                    "  FROM payment p "
                    "  JOIN rental r ON p.rental_id = r.rental_id "
                    "  JOIN inventory i ON r.inventory_id = i.inventory_id "
                    "  JOIN film f ON i.film_id = f.film_id "
                    "  JOIN film_category fc ON f.film_id = fc.film_id "
                    "  JOIN category c ON fc.category_id = c.category_id "
                    "  GROUP BY c.name, f.title"
                    ") "
                    "SELECT cr.category, cr.revenue, tf.title, tf.film_revenue "
                    "FROM cat_revenue cr "
                    "JOIN ("
                    "  SELECT category, MAX(film_revenue) AS max_revenue "
                    "  FROM top_films GROUP BY category"
                    ") tfmax ON cr.category = tfmax.category "
                    "JOIN top_films tf ON tf.category = tfmax.category AND tf.film_revenue = tfmax.max_revenue "
                    "ORDER BY cr.revenue DESC LIMIT 3;"
                ),
                "description": "Top 3 categories and their top-grossing film"
            },
            {
                "question": (
                    "Which actors have appeared in the most films that were never rented?"
                ),
                "expected_query": (
                    "SELECT a.first_name, a.last_name, COUNT(f.film_id) AS film_count "
                    "FROM actor a "
                    "JOIN film_actor fa ON a.actor_id = fa.actor_id "
                    "JOIN film f ON fa.film_id = f.film_id "
                    "LEFT JOIN inventory i ON f.film_id = i.film_id "
                    "LEFT JOIN rental r ON i.inventory_id = r.inventory_id "
                    "WHERE r.rental_id IS NULL "
                    "GROUP BY a.actor_id, a.first_name, a.last_name "
                    "ORDER BY film_count DESC;"
                ),
                "description": "Actors in most never-rented films"
            }
        ]

@pytest.fixture
def db_connection():
    """Create and return a database connection."""
    connection = sqlite3.connect(cfg.DB_PATH)
    yield connection
    connection.close()


class TestWriteQueryAzure:
    """Test cases for write_query_azure function by comparing query results."""

    def test_write_query_azure_results_comparison(self, db_connection):
        """
        Args:
            db_connection: Database connection fixture.
        This function will run a series of tests to validate the query generation and execution process.
        It will compare the results of the generated query against expected queries that are known to produce correct
        """

        cursor = db_connection.cursor()
        passed_tests = 0
        total_tests = len(test_cases)

        logger.info("ðŸ§ª Running %d query generation tests...", total_tests)

        for i, test_case in enumerate(test_cases):
            question = test_case["question"]
            expected_query = test_case["expected_query"]
            description = test_case["description"]

            logger.info("ðŸ” Test %d/%d: %s", i + 1, total_tests, description)
            logger.info("   Question: %s", question)

            # Step 1: Execute expected query to get correct results
            try:
                cursor.execute(expected_query)
                expected_results = cursor.fetchall()
                logger.info("   âœ“ Expected query executed: %d results",
                            len(expected_results))
                logger.info("   ðŸ“Š Expected query: %s", expected_query)
            except Exception as e:
                logger.error("   âŒ Error executing expected query: %s", e)
                continue

            # Step 2: Get relevant tables from vector database
            try:
                tables = query_collection_azure(prompt=question)
                if not tables or not tables.get("documents"):
                    logger.warning("   âš ï¸ No relevant tables found for question")
                    continue

                context_tables = "\n".join(tables["documents"])
                logger.info("   âœ“ Retrieved %d relevant tables",
                            len(tables['documents']))
                # Log the names of the tables retrieved, in order
                table_names = []
                for doc in tables["documents"]:
                    first_line = doc.strip().splitlines()[0]
                    table_name = ""
                    if "CREATE TABLE" in first_line.upper():
                        parts = first_line.split()
                        try:
                            table_name = parts[parts.index("TABLE") + 1]
                        except Exception:
                            table_name = first_line
                    else:
                        table_name = first_line
                    table_names.append(table_name)
                logger.info("      Table names (in order): %s",
                            ", ".join(table_names))

            except Exception as e:
                logger.error("   âŒ Error querying vector collection: %s", e)
                continue

            # Step 3: Generate query using Azure OpenAI
            try:
                result = write_query_azure(
                    question=question,
                    client=client,
                    context_tables=context_tables
                )

                generated_query = result.get("query")
                logger.info("   ðŸ¤– Generated query: %s", generated_query)

                if generated_query == "Error generating query":
                    logger.error("   âŒ Query generation failed")
                    continue

                if not generated_query.strip().lower().startswith("select"):
                    logger.warning(
                        "   âš ï¸ Generated query is not a SELECT statement"
                    )
                    continue

            except Exception as e:
                logger.error("   âŒ Error calling write_query_azure: %s", e)
                continue

            # Step 4: Execute generated query and compare results
            try:
                cursor.execute(generated_query)
                generated_results = cursor.fetchall()
                logger.info("   âœ“ Generated query executed: %d results",
                            len(generated_results))

                # Compare the results
                if self._compare_query_results(expected_results,
                                               generated_results):
                    logger.info("   âœ… TEST PASSED: Results match!")
                    passed_tests += 1
                else:
                    logger.error("   âŒ TEST FAILED: Results don't match")
                    logger.error("      Expected: %s",
                                 expected_results[:2]
                                 if len(expected_results) > 2
                                 else expected_results)
                    logger.error("      Generated: %s",
                                 generated_results[:2]
                                 if len(generated_results) > 2
                                 else generated_results)

            except Exception as e:
                logger.error("   âŒ Error executing generated query: %s", e)

            logger.info("")  # Add spacing between tests

        # Final summary
        logger.info("ðŸŽ¯ Test Summary: %d/%d tests passed (%.1f%%)",
                    passed_tests, total_tests,
                    passed_tests / total_tests * 100)

        # Assert that at least 70% of tests pass (adjust threshold as needed)
        assert passed_tests >= total_tests * 0.7, (
            f"Only {passed_tests}/{total_tests} tests passed. "
            "Expected at least 70%."
        )

    def _compare_query_results(self, expected, generated):
        """Compare two result sets, handling different data types and ordering."""
        if len(expected) != len(generated):
            return False

        # For single-value results (like COUNT, AVG, SUM)
        if len(expected) == 1 and len(expected[0]) == 1:
            # Handle floating point comparison for averages
            if isinstance(expected[0][0], (int, float)) and isinstance(
                    generated[0][0], (int, float)):
                return abs(float(expected[0][0]) - float(generated[0][0])) < 0.01
            return expected[0][0] == generated[0][0]

        # For multi-row results, compare as sets (ignoring order)
        try:
            expected_set = set(expected)
            generated_set = set(generated)
            return expected_set == generated_set
        except TypeError:
            # If results contain unhashable types, compare as sorted lists
            try:
                return sorted(expected) == sorted(generated)
            except TypeError:
                # If sorting fails, compare element by element (preserving order)
                return expected == generated

    def test_write_query_azure_error_handling(self):
        """Test error handling when no context tables are provided."""

        result = write_query_azure(
            question="Test question with no context",
            client=client,
            context_tables=""
        )

        # Should return error or handle gracefully
        assert "query" in result, "Result should contain 'query' key"
        logger.info("âœ… Error handling test: %s", result['query'])

    def test_vector_database_integration(self):
        """Test that vector database returns relevant tables for questions."""

        test_questions = [
            "How many actors are there?",
            "What is the average rental rate?",
            "How many customers do we have?"
        ]

        for question in test_questions:
            logger.info("ðŸ” Testing vector DB for: %s", question)

            try:
                tables = query_collection_azure(prompt=question)

                if tables and tables.get("documents"):
                    logger.info("   âœ“ Retrieved %d tables",
                                len(tables['documents']))
                    # Check that we got actual table schemas
                    for doc in tables["documents"][:2]:  # Show first 2
                        logger.info("   ðŸ“‹ Table info: %s...", doc[:100])
                else:
                    logger.warning("   âš ï¸ No tables retrieved")

            except Exception as e:
                logger.error("   âŒ Error querying vector database: %s", e)

    def test_write_query_azure_complex_questions(self, db_connection):
        """
        Integration test for write_query_azure with complex, multi-table or highly interpretive questions.
        This test validates that the LLM-generated SQL queries can handle advanced scenarios.
        """

        cursor = db_connection.cursor()
        passed_tests = 0
        total_tests = len(complex_cases)

        logger.info("ðŸ§ª Running %d complex query generation tests...", total_tests)

        for i, test_case in enumerate(complex_cases):
            question = test_case["question"]
            expected_query = test_case["expected_query"]
            description = test_case["description"]

            logger.info("ðŸ” Complex Test %d/%d: %s", i + 1, total_tests, description)
            logger.info("   Question: %s", question)

            # Step 1: Execute expected query to get correct results
            try:
                cursor.execute(expected_query)
                expected_results = cursor.fetchall()
                logger.info("   âœ“ Expected query executed: %d results",
                            len(expected_results))
                logger.info("   ðŸ“Š Expected query: %s", expected_query)
            except Exception as e:
                logger.error("   âŒ Error executing expected query: %s", e)
                continue

            # Step 2: Get relevant tables from vector database
            try:
                tables = query_collection_azure(prompt=question)
                if not tables or not tables.get("documents"):
                    logger.warning("   âš ï¸ No relevant tables found for question")
                    continue

                context_tables = "\n".join(tables["documents"])
                logger.info("   âœ“ Retrieved %d relevant tables",
                            len(tables['documents']))
                table_names = []
                for doc in tables["documents"]:
                    first_line = doc.strip().splitlines()[0]
                    table_name = ""
                    if "CREATE TABLE" in first_line.upper():
                        parts = first_line.split()
                        try:
                            table_name = parts[parts.index("TABLE") + 1]
                        except Exception:
                            table_name = first_line
                    else:
                        table_name = first_line
                    table_names.append(table_name)
                logger.info("      Table names (in order): %s",
                            ", ".join(table_names))

            except Exception as e:
                logger.error("   âŒ Error querying vector collection: %s", e)
                continue

            # Step 3: Generate query using Azure OpenAI
            try:
                result = write_query_azure(
                    question=question,
                    client=client,
                    context_tables=context_tables
                )

                generated_query = result.get("query")
                logger.info("   ðŸ¤– Generated query: %s", generated_query)

                if generated_query == "Error generating query":
                    logger.error("   âŒ Query generation failed")
                    continue

                if not generated_query.strip().lower().startswith("select"):
                    logger.warning(
                        "   âš ï¸ Generated query is not a SELECT statement"
                    )
                    continue

            except Exception as e:
                logger.error("   âŒ Error calling write_query_azure: %s", e)
                continue

            # Step 4: Execute generated query and compare results
            try:
                cursor.execute(generated_query)
                generated_results = cursor.fetchall()
                logger.info("   âœ“ Generated query executed: %d results",
                            len(generated_results))

                # Compare the results
                if self._compare_query_results(expected_results,
                                               generated_results):
                    logger.info("   âœ… COMPLEX TEST PASSED: Results match!")
                    passed_tests += 1
                else:
                    logger.error("   âŒ COMPLEX TEST FAILED: Results don't match")
                    logger.error("      Expected: %s",
                                 expected_results[:2]
                                 if len(expected_results) > 2
                                 else expected_results)
                    logger.error("      Generated: %s",
                                 generated_results[:2]
                                 if len(generated_results) > 2
                                 else generated_results)

            except Exception as e:
                logger.error("   âŒ Error executing generated query: %s", e)

            logger.info("")  # Add spacing between tests

        # Final summary
        logger.info("ðŸŽ¯ Complex Test Summary: %d/%d tests passed (%.1f%%)",
                    passed_tests, total_tests,
                    passed_tests / total_tests * 100)

        # Assert that at least 40% of complex tests pass (adjust threshold as needed)
        assert passed_tests >= total_tests * 0.4, (
            f"Only {passed_tests}/{total_tests} complex tests passed. "
            "Expected at least 40%."
        )


if __name__ == "__main__":
    # Run tests with verbose output
    pytest.main(["-v", "-s", __file__])